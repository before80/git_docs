+++
title = "gitignore"
weight = 30
type = "docs"
date = 2023-07-31T08:40:23+08:00
description = ""
isCJKLanguage = true
draft = false

+++

# gitignore

https://git-scm.com/docs/gitignore

version 2.41.0

## 名称

gitignore - Specifies intentionally untracked files to ignore

​	gitignore - 指定要忽略的有意不跟踪的文件

## 概述

`$XDG_CONFIG_HOME/git/ignore`, `$GIT_DIR/info/exclude`, `.gitignore`

## 描述

A `gitignore` file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected; see the NOTES below for details.

​	`gitignore` 文件用于指定 Git 应该忽略的有意不跟踪的文件。已经由 Git 跟踪的文件不受影响；有关详情，请参阅下面的“NOTES”。

Each line in a `gitignore` file specifies a pattern. When deciding whether to ignore a path, Git normally checks `gitignore` patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):

​	`gitignore` 文件中的每一行指定一个模式。在决定是否忽略路径时，Git 通常会检查来自多个来源的 `gitignore` 模式，其优先顺序如下（在一个优先级级别内，最后匹配的模式决定结果）：

- Patterns read from the command line for those commands that support them.
- 命令行中为支持它们的命令读取的模式。
- Patterns read from a `.gitignore` file in the same directory as the path, or in any parent directory (up to the top-level of the working tree), with patterns in the higher level files being overridden by those in lower level files down to the directory containing the file. These patterns match relative to the location of the `.gitignore` file. A project normally includes such `.gitignore` files in its repository, containing patterns for files generated as part of the project build.
- `.gitignore` 文件中的模式，该文件位于路径所在目录中，或位于任何父目录（直到工作树的顶层），较高级别文件中的模式会被较低级别文件中的模式覆盖，直至包含该文件的目录。这些模式相对于 `.gitignore` 文件的位置进行匹配。项目通常在其存储库中包含此类 `.gitignore` 文件，其中包含作为项目构建的一部分生成的文件的模式。
- Patterns read from `$GIT_DIR/info/exclude`.
- `$GIT_DIR/info/exclude` 中读取的模式。
- Patterns read from the file specified by the configuration variable `core.excludesFile`.
- 由配置变量 `core.excludesFile` 指定的文件中读取的模式。

Which file to place a pattern in depends on how the pattern is meant to be used.

​	将模式放在哪个文件中取决于模式的使用方式。

- Patterns which should be version-controlled and distributed to other repositories via clone (i.e., files that all developers will want to ignore) should go into a `.gitignore` file.
- 那些应该受版本控制并通过克隆分发给其他存储库的模式（即所有开发人员都希望忽略的文件）应该放在 `.gitignore` 文件中。
- Patterns which are specific to a particular repository but which do not need to be shared with other related repositories (e.g., auxiliary files that live inside the repository but are specific to one user’s workflow) should go into the `$GIT_DIR/info/exclude` file.
- 特定于特定存储库但不需要与其他相关存储库共享的模式（例如，位于存储库内但特定于某个用户工作流程的辅助文件）应该放在 `$GIT_DIR/info/exclude` 文件中。
- Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary files generated by the user’s editor of choice) generally go into a file specified by `core.excludesFile` in the user’s `~/.gitconfig`. Its default value is `$XDG_CONFIG_HOME/git/ignore`. If `$XDG_CONFIG_HOME` is either not set or empty, `$HOME/.config/git/ignore` is used instead.
- 用户希望 Git 在所有情况下都忽略的模式（例如，由用户选择的编辑器生成的备份或临时文件）通常放在用户的 `~/.gitconfig` 文件中指定的 `core.excludesFile` 所指定的文件中。其默认值为 `$XDG_CONFIG_HOME/git/ignore`。如果 `$XDG_CONFIG_HOME` 未设置或为空，则使用 `$HOME/.config/git/ignore`。

The underlying Git plumbing tools, such as *git ls-files* and *git read-tree*, read `gitignore` patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as *git status* and *git add*, use patterns from the sources specified above.

​	底层 Git 内部工具，例如 *git ls-files* 和 *git read-tree*，会从命令行选项指定的 `gitignore` 模式中读取，或从命令行选项指定的文件中读取。更高级别的 Git 工具，例如 *git status* 和 *git add*，则使用上述指定的来源中的模式。

## 模式格式

- A blank line matches no files, so it can serve as a separator for readability.
- 空行不匹配任何文件，因此它可以用作可读性的分隔符。
- A line starting with # serves as a comment. Put a backslash ("`\`") in front of the first hash for patterns that begin with a hash.
- 以 # 开头的行作为注释。对于以 # 开头的模式，请在第一个 # 前面加上反斜杠（“`\`”）。
- Trailing spaces are ignored unless they are quoted with backslash ("`\`").
- 忽略尾随空格，除非它们用反斜杠（“`\`”）引用。
- An optional prefix "`!`" which negates the pattern; any matching file excluded by a previous pattern will become included again. It is not possible to re-include a file if a parent directory of that file is excluded. Git doesn’t list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined. Put a backslash ("`\`") in front of the first "`!`" for patterns that begin with a literal "`!`", for example, "`\!important!.txt`".
- 可选前缀“`!`”用于否定模式；先前模式排除的任何匹配文件将重新包含在内。如果排除了该文件所在的父目录，则无法重新包含该文件。由于性能原因，Git 不会列出被排除的目录，因此包含在其中的文件的任何模式都不会生效，无论它们在何处定义。对于以字面“`!`”开头的模式，请在第一个“`!`”前面加上反斜杠（“`\`”），例如“`\!important!.txt`”。
- The slash */* is used as the directory separator. Separators may occur at the beginning, middle or end of the `.gitignore` search pattern.
- 斜杠“`/`”用作目录分隔符。分隔符可以出现在 `.gitignore` 搜索模式的开始、中间或结尾。
- If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular `.gitignore` file itself. Otherwise the pattern may also match at any level below the `.gitignore` level.
- 如果模式的开始或中间（或两者）有分隔符，则该模式相对于特定 `.gitignore` 文件的目录级别。否则，该模式也可以在 `.gitignore` 级别以下的任何级别匹配。
- If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories.
- 如果模式的末尾有分隔符，则该模式只匹配目录，否则该模式可以同时匹配文件和目录。
- For example, a pattern `doc/frotz/` matches `doc/frotz` directory, but not `a/doc/frotz` directory; however `frotz/` matches `frotz` and `a/frotz` that is a directory (all paths are relative from the `.gitignore` file).
- 例如，模式 `doc/frotz/` 匹配 `doc/frotz` 目录，但不匹配 `a/doc/frotz` 目录；然而，模式 `frotz/` 匹配 `frotz` 和 `a/frotz` 这是一个目录（所有路径都相对于 `.gitignore` 文件）。
- An asterisk "`*`" matches anything except a slash. The character "`?`" matches any one character except "`/`". The range notation, e.g. `[a-zA-Z]`, can be used to match one of the characters in a range. See fnmatch(3) and the FNM_PATHNAME flag for a more detailed description.
- 星号“`*`”匹配除斜杠之外的任何内容。字符“`?`”匹配除“`/`”之外的任何一个字符。范围表示法，例如 `[a-zA-Z]`，用于匹配范围内的字符之一。有关更详细的描述，请参阅 fnmatch(3) 和 FNM_PATHNAME 标志。

Two consecutive asterisks ("`**`") in patterns matched against full pathname may have special meaning:

​	模式与完整路径名匹配时，连续两个星号（“`**`”）可能具有特殊意义：

- A leading "`**`" followed by a slash means match in all directories. For example, "`**/foo`" matches file or directory "`foo`" anywhere, the same as pattern "`foo`". "`**/foo/bar`" matches file or directory "`bar`" anywhere that is directly under directory "`foo`".
- 以斜杠开头的“`**`”后跟一个斜杠表示在所有目录中匹配。例如，“`**/foo`”与文件或目录“foo”在任何地方匹配，与模式“foo”相同。“`**/foo/bar`”与直接位于目录“foo”下的文件或目录“bar”匹配。
- A trailing "`/**`" matches everything inside. For example, "`abc/**`" matches all files inside directory "`abc`", relative to the location of the `.gitignore` file, with infinite depth.
- 以“`/**`”结尾，表示匹配其中的所有内容。例如，“`abc/**`”与位于目录“abc”内的所有文件匹配，相对于 `.gitignore` 文件的位置，具有无限深度。
- A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, "`a/**/b`" matches "`a/b`", "`a/x/b`", "`a/x/y/b`" and so on.
- 斜杠后跟两个连续星号然后是一个斜杠，表示匹配零个或多个目录。例如，“`a/**/b`”与“`a/b`”、“`a/x/b`”、“`a/x/y/b`”等匹配。
- Other consecutive asterisks are considered regular asterisks and will match according to the previous rules.
- 其他连续星号视为常规星号，并根据前面的规则进行匹配。

## 配置

The optional configuration variable `core.excludesFile` indicates a path to a file containing patterns of file names to exclude, similar to `$GIT_DIR/info/exclude`. Patterns in the exclude file are used in addition to those in `$GIT_DIR/info/exclude`.

​	可选的配置变量 `core.excludesFile` 指示包含要排除的文件名模式的文件路径，类似于 `$GIT_DIR/info/exclude`。在排除文件中的模式会与 `$GIT_DIR/info/exclude` 中的模式一起使用。

## 注意

The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.

​	`gitignore` 文件的目的是确保 Git 中未跟踪的某些文件保持未跟踪状态。

To stop tracking a file that is currently tracked, use `git rm --cached`.

​	要停止跟踪当前已跟踪的文件，请使用 `git rm --cached` 命令。

Git does not follow symbolic links when accessing a `.gitignore` file in the working tree. This keeps behavior consistent when the file is accessed from the index or a tree versus from the filesystem.

​	Git 在访问工作树中的 `.gitignore` 文件时不会遵循符号链接。这样做是为了保持从索引或树访问文件与从文件系统访问文件时的行为一致。

## 示例

- The pattern `hello.*` matches any file or directory whose name begins with `hello.`. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. `/hello.*`; the pattern now matches `hello.txt`, `hello.c` but not `a/hello.java`.
- 模式 `hello.*` 匹配任何以 `hello.` 开头的文件或目录。如果只想将其限制在目录中而不在其子目录中，可以在模式前面加上斜杠，即 `/hello.*`；现在该模式匹配 `hello.txt`、`hello.c`，但不匹配 `a/hello.java`。
- The pattern `foo/` will match a directory `foo` and paths underneath it, but will not match a regular file or a symbolic link `foo` (this is consistent with the way how pathspec works in general in Git)
- 模式 `foo/` 将匹配目录 `foo` 及其下的路径，但不匹配常规文件或符号链接 `foo`（这与 Git 中 pathspec 的工作方式一致）
- The pattern `doc/frotz` and `/doc/frotz` have the same effect in any `.gitignore` file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.
- 模式 `doc/frotz` 和 `/doc/frotz` 在任何 `.gitignore` 文件中具有相同的效果。换句话说，如果模式中已经有中间斜杠，则前导斜杠不相关。
- The pattern "foo/*", matches "foo/test.json" (a regular file), "foo/bar" (a directory), but it does not match "foo/bar/hello.c" (a regular file), as the asterisk in the pattern does not match "bar/hello.c" which has a slash in it.
- 模式 "foo/*" 匹配 "foo/test.json"（常规文件）、"foo/bar"（目录），但不匹配 "foo/bar/hello.c"（常规文件），因为模式中的星号不匹配 "bar/hello.c"（其中有斜杠）。

```bash
    $ git status
    [...]
    # Untracked files:
    [...]
    #       Documentation/foo.html
    #       Documentation/gitignore.html
    #       file.o
    #       lib.a
    #       src/internal.o
    [...]
    $ cat .git/info/exclude
    # ignore objects and archives, anywhere in the tree.
    *.[oa]
    $ cat Documentation/.gitignore
    # ignore generated html files,
    *.html
    # except foo.html which is maintained by hand
    !foo.html
    $ git status
    [...]
    # Untracked files:
    [...]
    #       Documentation/foo.html
    [...]
```

Another example:

​	另一个示例：

```bash
    $ cat .gitignore
    vmlinux*
    $ ls arch/foo/kernel/vm*
    arch/foo/kernel/vmlinux.lds.S
    $ echo '!/vmlinux*' >arch/foo/kernel/.gitignore
```

The second .gitignore prevents Git from ignoring `arch/foo/kernel/vmlinux.lds.S`.

​	第二个 .gitignore 阻止 Git 忽略 `arch/foo/kernel/vmlinux.lds.S`。

Example to exclude everything except a specific directory `foo/bar` (note the `/*` - without the slash, the wildcard would also exclude everything within `foo/bar`):

​	排除除特定目录 `foo/bar` 之外的所有内容的示例（注意 `/*`，如果没有斜杠，则通配符也会排除 `foo/bar` 内的所有内容）：

```bash
    $ cat .gitignore
    # exclude everything except directory foo/bar
    /*
    !/foo
    /foo/*
    !/foo/bar
```

## 另请参阅

[git-rm[1]](https://git-scm.com/docs/git-rm), [gitrepository-layout[5]](https://git-scm.com/docs/gitrepository-layout), [git-check-ignore[1]](https://git-scm.com/docs/git-check-ignore)

## GIT

  这是[git[1]](../../Git)工具集中的一部分。